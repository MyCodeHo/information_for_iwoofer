# 开发思路

# 🚀 iWoofer Pro 开发路线图与实施策略

根据您当前的项目结构，我为您制定一个**分阶段、可迭代**的开发计划。

---

## 📊 当前项目状态评估

### ✅ 已完成部分
1. **完整的目录结构** - 符合 Clean Architecture
2. **Presentation 层基本完成**：
   - 所有主要视图已创建
   - ViewModels 已定义
   - 可复用组件库已搭建
   - 导航流程已实现
3. **Domain 层模型定义完整**
4. **架构文档完善**（PresentationREADME.md）

### ❌ 待实现部分
1. **Core 层核心逻辑** - 0% 完成
2. **Infrastructure 层适配** - 0% 完成
3. **Domain 层 UseCases** - 0% 完成
4. **数据持久化** - 0% 完成
5. **蓝牙通信** - 0% 完成
6. **音频处理引擎** - 0% 完成

---

## 🎯 开发策略：MVP 迭代法

采用 **最小可行产品（MVP）→ 功能迭代 → 优化完善** 的三阶段开发模式。

---

## 📅 第一阶段：MVP 核心功能（2-3周）

### 目标
打通从 UI 到蓝牙设备的完整数据流，实现基本的参数控制。

### 优先级 1：蓝牙连接（最高优先级）

#### 为什么先做蓝牙？
- **所有功能的基础** - 没有蓝牙连接，其他功能都是"空中楼阁"
- **验证硬件兼容性** - 尽早发现硬件通信问题
- **用户体验关键** - 连接稳定性决定用户满意度

#### 实现思路

**1.1 蓝牙管理器核心**
```
BluetoothManager.swift
├── 职责：
│   ├── 蓝牙状态监控（开启/关闭/未授权）
│   ├── 设备扫描（基于 Service UUID）
│   ├── 连接管理（连接/断开/重连）
│   └── 生命周期管理
│
├── 技术要点：
│   ├── 使用 CBCentralManager（CoreBluetooth 核心类）
│   ├── 实现 CBCentralManagerDelegate 协议
│   ├── 处理蓝牙权限请求（Info.plist 配置）
│   └── 状态机管理（.poweredOff → .scanning → .connecting → .connected）
│
└── 数据流：
    用户点击"扫描设备" 
    → ViewModel 调用 startScanning()
    → 发现设备后更新 @Published var discoveredDevices
    → UI 自动刷新设备列表
```

**1.2 设备连接流程**
```
连接流程图：
┌─────────────────────────────────────────────────────┐
│ 1. 用户在 DeviceListView 中点击设备                 │
└────────────────────┬────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│ 2. DeviceConnectionViewModel.connect(device)        │
└────────────────────┬────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│ 3. BluetoothManager.connect(peripheral)             │
│    - 调用 centralManager.connect()                  │
│    - 设置超时定时器（10秒）                         │
└────────────────────┬────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│ 4. 连接成功回调 didConnect(peripheral)              │
│    - 停止超时定时器                                 │
│    - 发现 Services: discoverServices([uuid])        │
└────────────────────┬────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│ 5. 发现 Characteristics                             │
│    - 遍历所有 Service                               │
│    - 发现每个 Service 的 Characteristics            │
│    - 保存 UUID → Characteristic 映射表              │
└────────────────────┬────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│ 6. 订阅 Notify Characteristics                      │
│    - 设置 notify: setNotifyValue(true, for: char)   │
│    - 监听设备主动推送的数据                         │
└────────────────────┬────────────────────────────────┘
                     ↓
┌─────────────────────────────────────────────────────┐
│ 7. 更新连接状态                                     │
│    - 更新 @Published var connectionState = .connected│
│    - UI 显示"已连接"图标                           │
│    - 导航到 MainControlView                         │
└─────────────────────────────────────────────────────┘
```

**1.3 断线重连机制**
```
重连策略：
├── 被动断线（设备超出范围/关闭）
│   ├── 检测 didDisconnectPeripheral 回调
│   ├── 判断是否为用户主动断开
│   └── 非主动断开 → 启动自动重连
│
├── 重连逻辑
│   ├── 第1次：立即重连（延迟0秒）
│   ├── 第2次：延迟2秒
│   ├── 第3次：延迟5秒
│   └── 3次失败 → 显示"设备已断开"提示
│
└── 用户手动重连
    └── UI 显示"重新连接"按钮
```

**1.4 蓝牙协议定义**
```
BluetoothProtocol.swift
├── Service UUID 定义
│   ├── 设备信息服务：0x180A
│   ├── 音频控制服务：0xAA00（自定义）
│   └── EQ 控制服务：0xBB00（自定义）
│
├── Characteristic UUID 定义
│   ├── 设备名称：0x2A00
│   ├── 固件版本：0x2A26
│   ├── Gain 控制：0xAA01
│   ├── Phase 控制：0xAA02
│   └── HP Filter：0xAA03
│
└── 数据包格式定义
    ├── 命令帧：[帧头][命令ID][参数ID][长度][数据][校验]
    ├── 响应帧：[帧头][状态码][长度][数据][校验]
    └── 示例：设置 Gain = 10dB
        发送：[0xAA][0x01][0x10][0x02][0x64 0x00][CRC]
        响应：[0xAA][0x00][0x00][CRC]（0x00 = 成功）
```

---

### 优先级 2：DSP 参数控制（核心功能）

#### 实现思路

**2.1 DSP 控制器架构**
```
DSPController.swift
├── 职责：
│   ├── 构建 DSP 命令（编码参数为字节数组）
│   ├── 通过蓝牙发送命令
│   ├── 解析设备响应
│   └── 错误处理与重试
│
├── 核心方法：
│   ├── setParameter(type: ParameterType, value: Double)
│   ├── getParameter(type: ParameterType) -> Double?
│   ├── syncAllParameters()
│   └── resetToDefault()
│
└── 参数类型枚举：
    enum ParameterType {
        case gain(range: -40...15)
        case phase(range: 0...180)
        case hpFilter(range: 20...200)
        case lpFilter(range: 50...500)
        // ...更多参数
    }
```

**2.2 命令构建流程**
```
用户拖动 Gain 滑块到 10dB
    ↓
MainControlViewModel.gain = 10.0
    ↓
防抖处理（debounce 0.3秒）
    ↓
DSPController.setParameter(.gain, value: 10.0)
    ↓
DSPCommandBuilder.buildCommand(
    commandID: 0x01,    // 设置参数命令
    paramID: 0x10,      // Gain 参数
    value: 10.0         // 10dB
)
    ↓
数据编码：
    10.0 dB → Int16(100) → [0x64, 0x00]
    构建完整命令：[0xAA, 0x01, 0x10, 0x02, 0x64, 0x00, CRC]
    ↓
BluetoothManager.writeValue(data, to: characteristic)
    ↓
等待设备响应（超时2秒）
    ↓
收到 ACK：[0xAA, 0x00, 0x00, CRC]
    ↓
解析状态码：0x00 = 成功
    ↓
更新 UI 显示 Toast："参数已同步"
```

**2.3 参数验证与约束**
```
参数验证层次：
1. UI 层验证
   ├── 滑块范围限制（range: -40...15）
   └── 推动逻辑（HP Filter < LP Filter）

2. ViewModel 层验证
   ├── 业务规则验证
   │   ├── Gain 不能与 Limiter Threshold 冲突
   │   └── Phase 与频率范围的关系
   └── 参数组合验证
       └── Crossover 频率必须在合理范围

3. DSP Controller 层验证
   ├── 数值范围最终检查
   ├── 类型转换溢出检查
   └── 命令格式验证
```

**2.4 错误处理策略**
```
错误类型 → 处理方式
├── 蓝牙连接断开
│   └── 暂停命令队列 → 显示"连接已断开" → 尝试重连
│
├── 命令超时（2秒无响应）
│   └── 重试1次 → 失败显示"设备无响应"
│
├── 设备返回错误码
│   ├── 0x01: 参数超出范围 → 显示"参数无效"
│   ├── 0x02: 设备忙碌 → 延迟重试
│   └── 0xFF: 未知错误 → 显示"设备错误"
│
└── 参数验证失败
    └── 拦截在 ViewModel 层 → 显示具体错误提示
```

---

### 优先级 3：数据持久化（预设管理）

#### 实现思路

**3.1 存储架构**
```
StorageManager.swift
├── 使用技术栈：
│   ├── UserDefaults: 简单配置（上次连接设备、偏好设置）
│   ├── FileManager: 预设文件（JSON 格式）
│   └── Keychain: 敏感数据（配对码）
│
├── 核心方法：
│   ├── savePreset(_ preset: PresetProfile)
│   ├── loadPreset(id: UUID) -> PresetProfile?
│   ├── deletePreset(id: UUID)
│   ├── listAllPresets() -> [PresetProfile]
│   └── exportPreset(_ preset: PresetProfile) -> URL
│
└── 文件结构：
    Documents/
    ├── Presets/
    │   ├── factory/              # 出厂预设（只读）
    │   │   ├── Rock.json
    │   │   ├── Jazz.json
    │   │   └── Classical.json
    │   └── user/                 # 用户预设
    │       ├── MyCustom1.json
    │       └── MyCustom2.json
    └── Measurements/             # 房间测量数据
        ├── LivingRoom_2025-01-10.json
        └── Bedroom_2025-01-11.json
```

**3.2 预设数据模型**
```
PresetProfile (Domain/Models/Preset/PresetProfile.swift)
{
    "id": "UUID",
    "name": "Rock - Heavy Bass",
    "author": "Jason",
    "category": "Music",
    "createdAt": "2025-01-23T10:30:00Z",
    "isFactory": false,
    "parameters": {
        "gain": 5.5,
        "phase": 0,
        "hpFilter": 35,
        "lpFilter": 120,
        "equalizer": {
            "bands": [
                {"frequency": 31, "gain": 6, "q": 1.0},
                {"frequency": 63, "gain": 4, "q": 1.0},
                ...
            ]
        },
        "crossover": {
            "hpFrequency": 80,
            "lpFrequency": 120,
            "slope": 24
        },
        "limiter": {
            "enabled": true,
            "threshold": -6,
            "ratio": 4
        }
    },
    "metadata": {
        "description": "适合摇滚乐的重低音设置",
        "tags": ["rock", "heavy", "bass"]
    }
}
```

**3.3 预设加载流程**
```
用户在 PresetListView 点击预设
    ↓
PresetViewModel.loadPreset(id: UUID)
    ↓
LoadPresetUseCase.execute(id)
    ↓
StorageManager.loadPreset(id)
    ↓
读取 JSON 文件 → 解析为 PresetProfile 对象
    ↓
验证参数有效性（版本兼容性检查）
    ↓
更新所有 ViewModel 的参数
    ├── MainControlViewModel.gain = preset.parameters.gain
    ├── EqualizerViewModel.bands = preset.parameters.equalizer.bands
    └── ...
    ↓
DSPController.syncAllParameters()
    ↓
批量发送所有参数到设备
    ↓
UI 显示 "预设已加载：Rock - Heavy Bass"
```

**3.4 预设导出/分享**
```
导出流程：
1. 用户点击"分享预设"
   ↓
2. 将 PresetProfile 序列化为 JSON
   ↓
3. 保存到临时文件：/tmp/Rock-HeavyBass.iwoofer
   ↓
4. 使用 UIActivityViewController 分享
   └── 支持：AirDrop、邮件、文件 App、其他 App

导入流程：
1. 用户通过"打开方式"选择 iWoofer Pro
   ↓
2. AppDelegate 接收文件 URL
   ↓
3. 验证文件格式（.iwoofer / .json）
   ↓
4. 解析 JSON → PresetProfile
   ↓
5. 保存到用户预设目录
   ↓
6. 导航到预设详情页面
```

---

### 优先级 4：UI 完善与交互优化

#### 实现思路

**4.1 连接状态指示**
```
ContentView 顶部状态栏：
┌─────────────────────────────────────────────────┐
│ [蓝牙图标] iWoofer Pro X1  信号：-65dBm ✓已连接 │
└─────────────────────────────────────────────────┘

状态显示逻辑：
├── 未连接：灰色图标 + "点击连接设备"
├── 扫描中：蓝色图标动画 + "正在扫描..."
├── 连接中：蓝色图标 + "连接中..."
└── 已连接：绿色图标 + 设备名称 + 信号强度
```

**4.2 参数同步反馈**
```
用户拖动滑块的反馈层次：
1. 实时 UI 更新（立即）
   └── Text 显示当前值

2. 防抖后发送（0.3秒后）
   └── 显示小圆点动画"正在同步..."

3. 设备确认（0.5-1秒后）
   ├── 成功：绿色勾号闪烁 → 消失
   └── 失败：红色叉号 + Toast 提示

4. 同步失败时的处理
   └── 滑块值回滚到上次成功值
```

**4.3 加载状态管理**
```
LoadingView 使用场景：
├── 连接设备时：全屏遮罩 + "正在连接..."
├── 加载预设时：局部遮罩 + "加载中..."
├── 同步参数时：小加载图标
└── 房间测量时：进度条 + "测量中... 30%"
```

---

## 📅 第二阶段：高级功能（3-4周）

### 目标
实现差异化功能，提升专业性和竞争力。

### 优先级 5：音频采集与分析

#### 实现思路

**5.1 音频引擎架构**
```
AudioCaptureEngine.swift
├── 使用 AVAudioEngine
│   ├── 配置 AVAudioSession（.playAndRecord 模式）
│   ├── 创建 AVAudioInputNode（麦克风输入）
│   ├── 安装 Tap（实时获取音频数据）
│   └── 控制录制（开始/停止/暂停）
│
├── 音频格式配置
│   ├── 采样率：48kHz（专业标准）
│   ├── 位深：16-bit
│   ├── 声道：单声道（测量用）
│   └── 缓冲大小：4096 samples
│
└── 数据流：
    麦克风 → AVAudioInputNode → Tap 回调 
    → 音频 Buffer → 传递给 FFTProcessor
```

**5.2 FFT 频谱分析**
```
FFTProcessor.swift
├── 使用 Accelerate 框架（高性能）
│   ├── vDSP_create_fftsetup()：创建 FFT 配置
│   ├── vDSP_fft_zrip()：执行实数 FFT
│   └── vDSP_zvmags()：计算幅度谱
│
├── 处理流程
│   ├── 输入：时域信号（4096 samples）
│   ├── 加窗：汉宁窗（Hanning Window）- 减少频谱泄漏
│   ├── FFT 变换：时域 → 频域
│   ├── 计算幅度：magnitude = sqrt(real^2 + imag^2)
│   └── 转换为 dB：dB = 20 * log10(magnitude)
│
└── 输出：频率 → 幅度 映射表
    [
        (31 Hz, -20 dB),
        (63 Hz, -15 dB),
        ...
        (16000 Hz, -40 dB)
    ]
```

**5.3 声压级测量**
```
SPLMeter.swift
├── 计算方法
│   ├── RMS（均方根）：sqrt(sum(samples^2) / n)
│   ├── 峰值：max(abs(samples))
│   └── dB SPL = 20 * log10(RMS / reference)
│
├── 校准
│   ├── 使用专业声压计校准（94dB @ 1kHz）
│   ├── 记录校准偏移量
│   └── 实际测量值 = 原始值 + 偏移量
│
└── 实时显示
    ├── 当前 SPL：85 dB
    ├── 峰值：92 dB
    └── 实时曲线图（类似录音软件的电平表）
```

---

### 优先级 6：房间校正（最复杂功能）

#### 实现思路

**6.1 测量流程设计**
```
RoomCorrectionEngine.swift - 测量向导

步骤 1：环境准备
├── 检查
│   ├── 蓝牙已连接
│   ├── 麦克风权限已授权
│   └── 环境安静（背景噪声 < 40dB）
└── 提示
    └── "请将麦克风放置在听音位置，距离低音炮 2-3 米"

步骤 2：播放测试信号
├── 信号类型选择
│   ├── 扫频信号（Sine Sweep）：20Hz-200Hz，持续 10 秒
│   └── 粉噪声（Pink Noise）：持续 5 秒
├── 通过蓝牙命令设备播放
└── 同时录制麦克风信号

步骤 3：频谱分析
├── FFT 分析录制的音频
├── 计算每个频率的能量
└── 生成频响曲线（20Hz-200Hz，每 1/3 倍频程）

步骤 4：目标曲线对比
├── 用户选择目标曲线
│   ├── 平坦（Flat）：所有频率相同能量
│   ├── Harman 曲线：低频略有提升
│   └── 自定义曲线：用户手动绘制
└── 计算差异：目标 - 实测

步骤 5：生成校正 EQ
├── 对每个频段计算所需增益
├── 限制校正范围（±10dB）
├── 平滑处理（移动平均）
└── 生成 EQ 参数列表
    [
        (31 Hz, -3 dB, Q=1.0),
        (63 Hz, +2 dB, Q=1.0),
        ...
    ]

步骤 6：应用校正
├── 将 EQ 参数发送到设备
├── 设备端 DSP 应用多段 EQ
└── 用户 A/B 对比（开启/关闭校正）
```

**6.2 算法优化策略**
```
挑战与解决方案：
├── 挑战 1：房间模态（驻波）导致峰谷明显
│   └── 解决：只校正宽峰谷，忽略窄峰（Q值过高）
│
├── 挑战 2：低频测量不准确（受房间影响大）
│   └── 解决：20-50Hz 限制校正幅度（±6dB）
│
├── 挑战 3：过度校正导致失真
│   └── 解决：设置最大校正量（±10dB）
│
└── 挑战 4：不同位置测量结果不同
    └── 解决：支持多点测量 → 平均结果
```

**6.3 可视化设计**
```
FrequencyResponseView.swift

显示元素：
├── 双曲线图
│   ├── 红色线：实测频响
│   ├── 绿色线：目标频响
│   └── 蓝色线：校正后预测
│
├── 频率轴（X轴）
│   ├── 对数刻度（20, 31.5, 50, 80, 125, 200 Hz）
│   └── 手势：捏合缩放、拖动平移
│
├── 增益轴（Y轴）
│   ├── -20dB ~ +20dB
│   └── 网格线（每 5dB）
│
└── 交互
    ├── 点击曲线显示详细数值
    ├── 拖动目标曲线调整期望频响
    └── 导出为图片/PDF
```

---

### 优先级 7：限幅器/压缩器

#### 实现思路

**7.1 实现架构**
```
LimiterSettings.swift (Domain/Models)
struct LimiterSettings {
    var enabled: Bool = true
    var threshold: Double = -6.0    // dB
    var ratio: Double = 4.0         // 4:1
    var attack: Double = 5.0        // ms
    var release: Double = 50.0      // ms
    var makeupGain: Double = 0.0    // dB
}

设备端处理（DSP 芯片）：
1. 实时检测信号电平（RMS 或峰值）
2. 超过阈值 → 计算增益衰减
3. 应用包络跟随器（Attack/Release）
4. 输出处理后的信号

App 端职责：
- 设置参数通过蓝牙发送
- 实时显示增益衰减量（设备通过 Notify 推送）
- 绘制增益衰减曲线
```

**7.2 UI 设计思路**
```
LimiterView.swift

布局：
┌──────────────────────────────────────────┐
│ Limiter / Compressor                     │
├──────────────────────────────────────────┤
│ ● Enabled                                │
│                                          │
│ Threshold: -6 dB  [=============○====]  │
│ Ratio: 4:1        [====○==============]  │
│ Attack: 5 ms      [===○===============]  │
│ Release: 50 ms    [========○==========]  │
│                                          │
│ ┌──────────────────────────────────────┐ │
│ │   增益衰减表头（实时显示）            │ │
│ │   -6dB ████████░░░░░░░░░░░░ 0dB       │ │
│ └──────────────────────────────────────┘ │
└──────────────────────────────────────────┘
```

---

## 📅 第三阶段：优化与完善（2-3周）

### 目标
提升用户体验、性能优化、错误处理、测试。

### 优先级 8：性能优化

#### 关键优化点

**8.1 蓝牙通信优化**
```
问题：频繁发送命令导致设备缓冲区溢出

解决方案：
├── 命令队列
│   ├── 将所有命令加入队列
│   ├── 按优先级排序（实时参数 > 预设加载）
│   └── 串行发送（等待上一个 ACK 再发下一个）
│
├── 批量更新
│   └── 预设加载时，打包所有参数为一个大命令
│
└── 防抖合并
    └── 0.3秒内多次修改同一参数 → 只发送最后一次
```

**8.2 FFT 性能优化**
```
问题：实时 FFT 计算消耗 CPU

解决方案：
├── 使用 Accelerate 框架（利用 GPU 加速）
├── 降低采样率（48kHz → 24kHz 测量用）
├── 减少 FFT 帧长（4096 → 2048）
└── 后台线程处理（DispatchQueue.global()）
```

**8.3 UI 渲染优化**
```
问题：频响曲线绘制卡顿

解决方案：
├── 使用 Canvas（SwiftUI）或 Core Graphics
├── 数据抽样（2048 点 → 100 点显示）
├── 缓存绘制路径
└── 只重绘变化的部分
```

---

### 优先级 9：错误处理与用户引导

#### 实现思路

**9.1 错误分类与提示**
```
ErrorType 枚举：
├── .bluetoothUnavailable
│   └── 提示："请在设置中开启蓝牙"
│
├── .deviceNotFound
│   └── 提示："未找到 iWoofer 设备，请确保设备已开启"
│
├── .connectionFailed
│   └── 提示："连接失败，请重试或重启设备"
│
├── .commandTimeout
│   └── 提示："设备无响应，请检查连接"
│
├── .microphonePermissionDenied
│   └── 提示："需要麦克风权限进行房间测量" + 跳转设置按钮
│
└── .invalidParameter
    └── 提示："参数超出范围：Gain 必须在 -40dB 到 +15dB"
```

**9.2 新手引导**
```
首次启动：
1. 欢迎页面 → 介绍核心功能
2. 权限请求 → 蓝牙 + 麦克风
3. 设备连接教程 → 动画演示
4. 快速设置向导 → 推荐初始参数
```

---

### 优先级 10：测试

#### 测试策略

**10.1 单元测试**
```
需要测试的模块：
├── DSPCommandBuilder
│   └── 测试命令编码正确性
│
├── FFTProcessor
│   └── 测试 FFT 输出准确性
│
├── BluetoothProtocol
│   └── 测试数据包解析
│
└── PresetRepository
    └── 测试预设保存/加载
```

**10.2 集成测试**
```
测试场景：
├── 蓝牙连接流程（扫描 → 连接 → 发现服务）
├── 参数同步流程（UI → ViewModel → DSP → 设备）
└── 预设加载流程（文件 → 解析 → 应用 → UI 更新）
```

**10.3 真机测试**
```
测试设备：
├── iPhone 13 Pro（iOS 17）
├── iPhone SE 2020（iOS 15）
└── iPad Pro（验证布局适配）
```

---

## 🎯 开发优先级矩阵

| 功能模块 | 优先级 | 复杂度 | 时间估算 | 依赖关系 |
|---------|-------|--------|---------|---------|
| **蓝牙连接** | ⭐⭐⭐⭐⭐ | 中 | 5天 | 无 |
| **DSP 控制** | ⭐⭐⭐⭐⭐ | 中 | 4天 | 蓝牙连接 |
| **数据持久化** | ⭐⭐⭐⭐ | 低 | 3天 | 无 |
| **UI 完善** | ⭐⭐⭐⭐ | 低 | 3天 | DSP 控制 |
| **音频采集** | ⭐⭐⭐ | 高 | 5天 | 无 |
| **FFT 分析** | ⭐⭐⭐ | 高 | 4天 | 音频采集 |
| **房间校正** | ⭐⭐ | 极高 | 7天 | FFT 分析 |
| **限幅器** | ⭐⭐ | 中 | 3天 | DSP 控制 |
| **性能优化** | ⭐⭐ | 中 | 3天 | 所有功能 |
| **测试** | ⭐⭐⭐ | 低 | 4天 | 所有功能 |

---

## 📈 开发里程碑

### 里程碑 1：MVP 版本（第 3 周末）
- ✅ 蓝牙扫描与连接
- ✅ 基本参数控制（Gain、Phase、HP/LP Filter）
- ✅ 预设保存/加载
- ✅ 基本 UI 交互

**验收标准：**
- 能够连接真实设备（或模拟器）
- 能够调节参数并同步到设备
- 能够保存和加载预设
- 无严重 Bug

---

### 里程碑 2：功能完整版（第 6-7 周末）
- ✅ 所有 DSP 参数控制
- ✅ 音频测量与分析
- ✅ 房间校正（基础版）
- ✅ 限幅器/压缩器
- ✅ 完整的错误处理

**验收标准：**
- 所有核心功能可用
- 房间测量能生成校正 EQ
- 用户体验流畅

---

### 里程碑 3：优化版（第 9-10 周末）
- ✅ 性能优化
- ✅ UI/UX 打磨
- ✅ 完整测试覆盖
- ✅ 用户文档

**验收标准：**
- 无卡顿
- 无崩溃
- 通过所有测试用例

---

## 🔄 迭代开发建议

### 每周迭代计划

**Week 1-2：基础设施**
- [ ] 完成 BluetoothManager
- [ ] 完成 DeviceScanView 和 DeviceListView
- [ ] 测试蓝牙连接流程

**Week 3-4：核心控制**
- [ ] 完成 DSPController
- [ ] 完成 MainControlViewModel 逻辑
- [ ] 测试参数同步

**Week 5-6：高级功能**
- [ ] 完成音频采集
- [ ] 完成 FFT 分析
- [ ] 开始房间校正

**Week 7-8：功能完善**
- [ ] 完成房间校正
- [ ] 完成限幅器
- [ ] 完成预设导入/导出

**Week 9-10：优化与测试**
- [ ] 性能优化
- [ ] 错误处理
- [ ] 全面测试

---

## 🎓 学习建议

在开发过程中，您需要深入学习以下技术：

### 必须掌握
1. **CoreBluetooth 框架**
   - CBCentralManager
   - CBPeripheral
   - GATT 协议

2. **AVFoundation 音频**
   - AVAudioEngine
   - AVAudioSession
   - Audio Buffer 处理

3. **Accelerate 框架**
   - vDSP FFT 函数
   - 向量运算

### 推荐阅读
- Apple 官方文档：Core Bluetooth Programming Guide
- Apple 官方文档：Audio Unit Programming Guide
- 《The Audio Programming Book》
- 开源项目：AudioKit（音频处理库）

---

## 💡 最后建议

1. **从简单开始**：先实现 MVP，再迭代完善
2. **频繁测试**：每完成一个模块立即测试
3. **代码审查**：定期检查代码质量
4. **文档同步**：边开发边写文档
5. **用户反馈**：尽早找用户测试

---

**总结：您现在的架构非常完善，接下来按照这个计划，从蓝牙连接开始，逐步实现每个功能模块即可！** 🚀